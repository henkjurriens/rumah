{"ast":null,"code":"import { __rest } from 'tslib';\nimport { createBrowserHistory, createHashHistory } from 'history';\nimport React from 'react';\nimport { matchPath as matchPath$1, withRouter, Router } from 'react-router-dom';\nimport { ViewStacks, generateId, IonRoute, ViewLifeCycleManager, StackContext, RouteManagerContext, getConfig, LocationHistory, NavManager } from '@ionic/react';\nimport { Route, matchPath, Router as Router$1 } from 'react-router';\n\nclass IonRouteInner extends React.PureComponent {\n  render() {\n    return React.createElement(Route, {\n      path: this.props.path,\n      exact: this.props.exact,\n      render: this.props.render,\n      computedMatch: this.props.computedMatch\n    });\n  }\n\n}\n\nclass ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n\n  createViewItem(outletId, reactElement, routeInfo, page) {\n    const viewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false\n    };\n    const matchProps = {\n      exact: reactElement.props.exact,\n      path: reactElement.props.path || reactElement.props.from,\n      component: reactElement.props.component\n    };\n    const match = matchPath(routeInfo.pathname, matchProps);\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match,\n      childProps: reactElement.props\n    };\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId); // Sync latest routes with viewItems\n\n    React.Children.forEach(ionRouterOutlet.props.children, child => {\n      const viewItem = viewItems.find(v => {\n        return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n    const children = viewItems.map(viewItem => {\n      let clonedChild;\n\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = React.createElement(ViewLifeCycleManager, {\n          key: `view-${viewItem.id}`,\n          mount: viewItem.mount,\n          removeView: () => this.remove(viewItem)\n        }, React.cloneElement(viewItem.reactElement, {\n          computedMatch: viewItem.routeData.match\n        }));\n      } else {\n        const match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = React.createElement(ViewLifeCycleManager, {\n          key: `view-${viewItem.id}`,\n          mount: viewItem.mount,\n          removeView: () => this.remove(viewItem)\n        }, React.cloneElement(viewItem.reactElement, {\n          computedMatch: viewItem.routeData.match\n        }));\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo, outletId) {\n    const {\n      viewItem,\n      match\n    } = this.findViewItemByPath(routeInfo.pathname, outletId);\n\n    if (viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo, outletId, mustBeIonRoute = true) {\n    const {\n      viewItem\n    } = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute);\n    return viewItem;\n  }\n\n  findViewItemByPathname(pathname, outletId) {\n    const {\n      viewItem\n    } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n\n  findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {\n    let viewItem;\n    let match;\n    let viewStack;\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return {\n      viewItem,\n      match\n    };\n\n    function matchView(v) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n\n      const matchProps = {\n        exact: forceExact ? true : v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component\n      };\n      const myMatch = matchPath(pathname, matchProps);\n\n      if (myMatch) {\n        viewItem = v;\n        match = myMatch;\n        return true;\n      }\n\n      return false;\n    }\n\n    function matchDefaultRoute(v) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {}\n        };\n        viewItem = v;\n        return true;\n      }\n\n      return false;\n    }\n  }\n\n}\n\nfunction matchComponent$1(node, pathname, forceExact) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  const match = matchPath(pathname, matchProps);\n  return match;\n}\n\nfunction clonePageElement(leavingViewHtml) {\n  let html;\n\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = ''; // Remove an existing back button so the new element doesn't get two of them\n\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n\n    return newEl.firstChild;\n  }\n\n  return undefined;\n}\n\nclass StackManager extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.stackContextValue = {\n      registerIonPage: this.registerIonPage.bind(this),\n      isInOutlet: () => true\n    };\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n  }\n\n  componentDidMount() {\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement); // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname) {\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentWillUnmount() {\n    // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n    this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo) {\n    var _a, _b; // If routerOutlet isn't quite ready, give it another try in a moment\n\n\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      setTimeout(() => this.handlePageTransition(routeInfo), 10);\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n      } // Check if leavingViewItem should be unmounted\n\n\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);\n\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      }\n\n      if (!enteringViewItem) {\n        if (enteringRoute) {\n          enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n          this.context.addViewItem(enteringViewItem);\n        }\n      }\n\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        } // }, 250);\n\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page, routeInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n\n    if (foundView) {\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n    }\n\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n\n      if (swipeEnabled) {\n        return this.context.canGoBack();\n      } else {\n        return false;\n      }\n    };\n\n    const onStart = () => {\n      this.context.goBack();\n    };\n\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd: _shouldContinue => true\n    };\n  }\n\n  async transitionPage(routeInfo, enteringViewItem, leavingViewItem) {\n    const routerOutlet = this.routerOutletElement;\n    const direction = routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);\n\n        if (leavingViewItem && leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n\n    async function runCommit(enteringEl, leavingEl) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        deepWait: true,\n        duration: direction === undefined ? 0 : undefined,\n        direction: direction,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation: false,\n        animationBuilder: routeInfo.routeAnimation\n      });\n    }\n  }\n\n  render() {\n    const {\n      children\n    } = this.props;\n    const ionRouterOutlet = React.Children.only(children);\n    this.ionRouterOutlet = ionRouterOutlet;\n    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {\n      this.forceUpdate();\n    });\n    return React.createElement(StackContext.Provider, {\n      value: this.stackContextValue\n    }, React.cloneElement(ionRouterOutlet, {\n      ref: node => {\n        if (ionRouterOutlet.props.setRef) {\n          ionRouterOutlet.props.setRef(node);\n        }\n\n        if (ionRouterOutlet.props.forwardedRef) {\n          ionRouterOutlet.props.forwardedRef.current = node;\n        }\n\n        this.routerOutletElement = node;\n        const {\n          ref\n        } = ionRouterOutlet;\n\n        if (typeof ref === 'function') {\n          ref(node);\n        }\n      }\n    }, components));\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n\n}\n\nfunction matchRoute(node, routeInfo) {\n  let matchedNode;\n  React.Children.forEach(node, child => {\n    const matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component\n    };\n    const match = matchPath$1(routeInfo.pathname, matchProps);\n\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  } // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n\n\n  React.Children.forEach(node, child => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n  return matchedNode;\n}\n\nfunction matchComponent(node, pathname, forceExact) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  const match = matchPath$1(pathname, matchProps);\n  return match;\n}\n\nclass IonRouterInner extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.exitViewFromOtherOutletHandlers = [];\n    this.locationHistory = new LocationHistory();\n    this.viewStack = new ReactRouterViewStack();\n    this.routeMangerContextState = {\n      canGoBack: () => this.locationHistory.canGoBack(),\n      clearOutlet: this.viewStack.clear,\n      findViewItemByPathname: this.viewStack.findViewItemByPathname,\n      getChildrenToRender: this.viewStack.getChildrenToRender,\n      goBack: () => this.handleNavigateBack(),\n      createViewItem: this.viewStack.createViewItem,\n      findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n      findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n      addViewItem: this.viewStack.add,\n      unMountViewItem: this.viewStack.remove\n    };\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search\n    };\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n    this.state = {\n      routeInfo\n    };\n  }\n\n  handleChangeTab(tab, path, routeOptions) {\n    if (!path) {\n      return;\n    }\n\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n\n    if (routeInfo) {\n      this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), {\n        routeAction: 'push',\n        routeDirection: 'none'\n      });\n\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location, action) {\n    var _a, _b, _c;\n\n    let leavingLocationInfo;\n\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab\n          };\n        }\n\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n              routeAction: 'pop',\n              routeDirection: 'back'\n            });\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab\n            };\n          }\n        }\n\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || 'forward',\n            routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,\n            tab: this.currentTab\n          };\n        }\n      }\n\n      let routeInfo;\n\n      if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {\n        routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname\n        });\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed = this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = Object.assign(Object.assign({\n          id: generateId('routeInfo')\n        }, this.incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname\n        });\n\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n\n          const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n          const pushedByRoute = currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;\n          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n          routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;\n          routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n\n\n  handleNativeBack() {\n    const history = this.props.history;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n\n  handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab\n    });\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref = '/', routeAnimation) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref');\n    const routeInfo = this.locationHistory.current();\n\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n\n      if (prevInfo) {\n        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: routeAnimation || routeInfo.routeAnimation\n        });\n\n        if (routeInfo.lastPathname === routeInfo.pushedByRoute ||\n        /**\n         * We need to exclude tab switches/tab\n         * context changes here because tabbed\n         * navigation is not linear, but router.back()\n         * will go back in a linear fashion.\n         */\n        prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '') {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref, 'pop', 'back');\n      }\n    } else {\n      this.handleNavigate(defaultHref, 'pop', 'back');\n    }\n  }\n\n  handleResetTab(tab, originalHref, originalRouteOptions) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n\n    if (routeInfo) {\n      const newRouteInfo = Object.assign({}, routeInfo);\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), {\n        routeAction: 'pop',\n        routeDirection: 'back'\n      });\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab) {\n    this.currentTab = tab;\n    const ri = Object.assign({}, this.locationHistory.current());\n\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return React.createElement(RouteManagerContext.Provider, {\n      value: this.routeMangerContextState\n    }, React.createElement(NavManager, {\n      ionRoute: IonRouteInner,\n      ionRedirect: {},\n      stackManager: StackManager,\n      routeInfo: this.state.routeInfo,\n      onNativeBack: this.handleNativeBack,\n      onNavigateBack: this.handleNavigateBack,\n      onNavigate: this.handleNavigate,\n      onSetCurrentTab: this.handleSetCurrentTab,\n      onChangeTab: this.handleChangeTab,\n      onResetTab: this.handleResetTab,\n      locationHistory: this.locationHistory\n    }, this.props.children));\n  }\n\n}\n\nconst IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n\nclass IonReactRouter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const {\n      history\n    } = props,\n          rest = __rest(props, [\"history\"]);\n\n    this.history = history || createBrowserHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router, Object.assign({\n      history: this.history\n    }, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nclass IonReactMemoryRouter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router$1, Object.assign({}, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nclass IonReactHashRouter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const {\n      history\n    } = props,\n          rest = __rest(props, [\"history\"]);\n\n    this.history = history || createHashHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router, Object.assign({\n      history: this.history\n    }, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nexport { IonReactHashRouter, IonReactMemoryRouter, IonReactRouter };","map":{"version":3,"sources":["/Users/henk/Projects/rumah/rumah/node_modules/@ionic/react-router/dist/index.esm.js"],"names":["__rest","createBrowserHistory","createHashHistory","React","matchPath","matchPath$1","withRouter","Router","ViewStacks","generateId","IonRoute","ViewLifeCycleManager","StackContext","RouteManagerContext","getConfig","LocationHistory","NavManager","Route","Router$1","IonRouteInner","PureComponent","render","createElement","path","props","exact","computedMatch","ReactRouterViewStack","constructor","createViewItem","bind","findViewItemByRouteInfo","findLeavingViewItemByRouteInfo","getChildrenToRender","findViewItemByPathname","outletId","reactElement","routeInfo","page","viewItem","id","ionPageElement","mount","ionRoute","matchProps","from","component","match","pathname","type","disableIonPageManagement","routeData","childProps","ionRouterOutlet","viewItems","getViewItemsForOutlet","Children","forEach","children","child","find","v","matchComponent$1","map","clonedChild","key","removeView","remove","cloneElement","undefined","findViewItemByPath","mustBeIonRoute","lastPathname","forceExact","viewStack","some","matchView","matchDefaultRoute","getAllViewItems","myMatch","url","isExact","params","node","clonePageElement","leavingViewHtml","html","outerHTML","document","newEl","innerHTML","style","zIndex","ionBackButton","getElementsByTagName","firstChild","StackManager","stackContextValue","registerIonPage","isInOutlet","transitionPage","handlePageTransition","componentDidMount","routerOutletElement","setupRouterOutlet","componentDidUpdate","prevProps","componentWillUnmount","context","clearOutlet","_a","_b","commit","setTimeout","enteringViewItem","leavingViewItem","prevRouteLastPathname","routeAction","routeDirection","routeOptions","unmount","enteringRoute","matchRoute","addViewItem","classList","add","setAttribute","forceUpdate","foundView","routerOutlet","canStart","config","swipeEnabled","get","mode","canGoBack","onStart","goBack","swipeHandler","onEnd","_shouldContinue","direction","matchComponent","newLeavingElement","appendChild","runCommit","removeChild","enteringEl","leavingEl","deepWait","duration","showGoBack","pushedByRoute","progressAnimation","animationBuilder","routeAnimation","only","components","Provider","value","ref","setRef","forwardedRef","current","contextType","matchedNode","IonRouterInner","exitViewFromOtherOutletHandlers","locationHistory","routeMangerContextState","clear","handleNavigateBack","unMountViewItem","location","search","handleChangeTab","handleResetTab","handleNativeBack","handleNavigate","registerHistoryListener","handleHistoryChange","handleSetCurrentTab","state","tab","getCurrentRouteInfoForTab","split","incomingRouteParams","Object","assign","history","push","action","_c","leavingLocationInfo","previous","leavingUrl","currentTab","currentRoute","prevInfo","findLastLocation","routerOptions","isPushed","r","lastRoute","currentRouteInfo","currentPushedBy","setState","back","replace","defaultHref","originalHref","originalRouteOptions","getFirstRouteInfoForTab","newRouteInfo","ri","update","ionRedirect","stackManager","onNativeBack","onNavigateBack","onNavigate","onSetCurrentTab","onChangeTab","onResetTab","IonRouter","displayName","IonReactRouter","Component","rest","listen","locationValue","actionValue","historyListenHandler","cb","IonReactMemoryRouter","IonReactHashRouter"],"mappings":"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","sourcesContent":["import { __rest } from 'tslib';\nimport { createBrowserHistory, createHashHistory } from 'history';\nimport React from 'react';\nimport { matchPath as matchPath$1, withRouter, Router } from 'react-router-dom';\nimport { ViewStacks, generateId, IonRoute, ViewLifeCycleManager, StackContext, RouteManagerContext, getConfig, LocationHistory, NavManager } from '@ionic/react';\nimport { Route, matchPath, Router as Router$1 } from 'react-router';\n\nclass IonRouteInner extends React.PureComponent {\n    render() {\n        return (React.createElement(Route, { path: this.props.path, exact: this.props.exact, render: this.props.render, computedMatch: this.props.computedMatch }));\n    }\n}\n\nclass ReactRouterViewStack extends ViewStacks {\n    constructor() {\n        super();\n        this.createViewItem = this.createViewItem.bind(this);\n        this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n        this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n        this.getChildrenToRender = this.getChildrenToRender.bind(this);\n        this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n    }\n    createViewItem(outletId, reactElement, routeInfo, page) {\n        const viewItem = {\n            id: generateId('viewItem'),\n            outletId,\n            ionPageElement: page,\n            reactElement,\n            mount: true,\n            ionRoute: false,\n        };\n        const matchProps = {\n            exact: reactElement.props.exact,\n            path: reactElement.props.path || reactElement.props.from,\n            component: reactElement.props.component,\n        };\n        const match = matchPath(routeInfo.pathname, matchProps);\n        if (reactElement.type === IonRoute) {\n            viewItem.ionRoute = true;\n            viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n        }\n        viewItem.routeData = {\n            match,\n            childProps: reactElement.props,\n        };\n        return viewItem;\n    }\n    getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {\n        const viewItems = this.getViewItemsForOutlet(outletId);\n        // Sync latest routes with viewItems\n        React.Children.forEach(ionRouterOutlet.props.children, (child) => {\n            const viewItem = viewItems.find((v) => {\n                return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);\n            });\n            if (viewItem) {\n                viewItem.reactElement = child;\n            }\n        });\n        const children = viewItems.map((viewItem) => {\n            let clonedChild;\n            if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n                clonedChild = (React.createElement(ViewLifeCycleManager, { key: `view-${viewItem.id}`, mount: viewItem.mount, removeView: () => this.remove(viewItem) }, React.cloneElement(viewItem.reactElement, {\n                    computedMatch: viewItem.routeData.match,\n                })));\n            }\n            else {\n                const match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);\n                clonedChild = (React.createElement(ViewLifeCycleManager, { key: `view-${viewItem.id}`, mount: viewItem.mount, removeView: () => this.remove(viewItem) }, React.cloneElement(viewItem.reactElement, {\n                    computedMatch: viewItem.routeData.match,\n                })));\n                if (!match && viewItem.routeData.match) {\n                    viewItem.routeData.match = undefined;\n                    viewItem.mount = false;\n                }\n            }\n            return clonedChild;\n        });\n        return children;\n    }\n    findViewItemByRouteInfo(routeInfo, outletId) {\n        const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);\n        if (viewItem && match) {\n            viewItem.routeData.match = match;\n        }\n        return viewItem;\n    }\n    findLeavingViewItemByRouteInfo(routeInfo, outletId, mustBeIonRoute = true) {\n        const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute);\n        return viewItem;\n    }\n    findViewItemByPathname(pathname, outletId) {\n        const { viewItem } = this.findViewItemByPath(pathname, outletId);\n        return viewItem;\n    }\n    findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {\n        let viewItem;\n        let match;\n        let viewStack;\n        if (outletId) {\n            viewStack = this.getViewItemsForOutlet(outletId);\n            viewStack.some(matchView);\n            if (!viewItem) {\n                viewStack.some(matchDefaultRoute);\n            }\n        }\n        else {\n            const viewItems = this.getAllViewItems();\n            viewItems.some(matchView);\n            if (!viewItem) {\n                viewItems.some(matchDefaultRoute);\n            }\n        }\n        return { viewItem, match };\n        function matchView(v) {\n            if (mustBeIonRoute && !v.ionRoute) {\n                return false;\n            }\n            const matchProps = {\n                exact: forceExact ? true : v.routeData.childProps.exact,\n                path: v.routeData.childProps.path || v.routeData.childProps.from,\n                component: v.routeData.childProps.component,\n            };\n            const myMatch = matchPath(pathname, matchProps);\n            if (myMatch) {\n                viewItem = v;\n                match = myMatch;\n                return true;\n            }\n            return false;\n        }\n        function matchDefaultRoute(v) {\n            // try to find a route that doesn't have a path or from prop, that will be our default route\n            if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n                match = {\n                    path: pathname,\n                    url: pathname,\n                    isExact: true,\n                    params: {},\n                };\n                viewItem = v;\n                return true;\n            }\n            return false;\n        }\n    }\n}\nfunction matchComponent$1(node, pathname, forceExact) {\n    const matchProps = {\n        exact: forceExact ? true : node.props.exact,\n        path: node.props.path || node.props.from,\n        component: node.props.component,\n    };\n    const match = matchPath(pathname, matchProps);\n    return match;\n}\n\nfunction clonePageElement(leavingViewHtml) {\n    let html;\n    if (typeof leavingViewHtml === 'string') {\n        html = leavingViewHtml;\n    }\n    else {\n        html = leavingViewHtml.outerHTML;\n    }\n    if (document) {\n        const newEl = document.createElement('div');\n        newEl.innerHTML = html;\n        newEl.style.zIndex = '';\n        // Remove an existing back button so the new element doesn't get two of them\n        const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n        if (ionBackButton[0]) {\n            ionBackButton[0].remove();\n        }\n        return newEl.firstChild;\n    }\n    return undefined;\n}\n\nclass StackManager extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.stackContextValue = {\n            registerIonPage: this.registerIonPage.bind(this),\n            isInOutlet: () => true,\n        };\n        this.registerIonPage = this.registerIonPage.bind(this);\n        this.transitionPage = this.transitionPage.bind(this);\n        this.handlePageTransition = this.handlePageTransition.bind(this);\n        this.id = generateId('routerOutlet');\n    }\n    componentDidMount() {\n        if (this.routerOutletElement) {\n            this.setupRouterOutlet(this.routerOutletElement);\n            // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n            this.handlePageTransition(this.props.routeInfo);\n        }\n    }\n    componentDidUpdate(prevProps) {\n        if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname) {\n            this.handlePageTransition(this.props.routeInfo);\n        }\n    }\n    componentWillUnmount() {\n        // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n        this.context.clearOutlet(this.id);\n    }\n    async handlePageTransition(routeInfo) {\n        var _a, _b;\n        // If routerOutlet isn't quite ready, give it another try in a moment\n        if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n            setTimeout(() => this.handlePageTransition(routeInfo), 10);\n        }\n        else {\n            let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n            let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n            if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n                leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n            }\n            // Check if leavingViewItem should be unmounted\n            if (leavingViewItem) {\n                if (routeInfo.routeAction === 'replace') {\n                    leavingViewItem.mount = false;\n                }\n                else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n                    if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n                        leavingViewItem.mount = false;\n                    }\n                }\n                else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {\n                    leavingViewItem.mount = false;\n                }\n            }\n            const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);\n            if (enteringViewItem) {\n                enteringViewItem.reactElement = enteringRoute;\n            }\n            if (!enteringViewItem) {\n                if (enteringRoute) {\n                    enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n                    this.context.addViewItem(enteringViewItem);\n                }\n            }\n            if (enteringViewItem && enteringViewItem.ionPageElement) {\n                this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n            }\n            else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n                // If we have a leavingView but no entering view/route, we are probably leaving to\n                // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n                // transition to finish.\n                // setTimeout(() => {\n                if (leavingViewItem.ionPageElement) {\n                    leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n                    leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n                }\n                // }, 250);\n            }\n            this.forceUpdate();\n        }\n    }\n    registerIonPage(page, routeInfo) {\n        const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n        if (foundView) {\n            foundView.ionPageElement = page;\n            foundView.ionRoute = true;\n        }\n        this.handlePageTransition(routeInfo);\n    }\n    async setupRouterOutlet(routerOutlet) {\n        const canStart = () => {\n            const config = getConfig();\n            const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n            if (swipeEnabled) {\n                return this.context.canGoBack();\n            }\n            else {\n                return false;\n            }\n        };\n        const onStart = () => {\n            this.context.goBack();\n        };\n        routerOutlet.swipeHandler = {\n            canStart,\n            onStart,\n            onEnd: (_shouldContinue) => true,\n        };\n    }\n    async transitionPage(routeInfo, enteringViewItem, leavingViewItem) {\n        const routerOutlet = this.routerOutletElement;\n        const direction = routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root'\n            ? undefined\n            : routeInfo.routeDirection;\n        if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n            if (leavingViewItem &&\n                leavingViewItem.ionPageElement &&\n                enteringViewItem === leavingViewItem) {\n                // If a page is transitioning to another version of itself\n                // we clone it so we can have an animation to show\n                const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n                if (match) {\n                    const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n                    if (newLeavingElement) {\n                        this.routerOutletElement.appendChild(newLeavingElement);\n                        await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n                        this.routerOutletElement.removeChild(newLeavingElement);\n                    }\n                }\n                else {\n                    await runCommit(enteringViewItem.ionPageElement, undefined);\n                }\n            }\n            else {\n                await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);\n                if (leavingViewItem && leavingViewItem.ionPageElement) {\n                    leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n                    leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n                }\n            }\n        }\n        async function runCommit(enteringEl, leavingEl) {\n            enteringEl.classList.add('ion-page');\n            enteringEl.classList.add('ion-page-invisible');\n            await routerOutlet.commit(enteringEl, leavingEl, {\n                deepWait: true,\n                duration: direction === undefined ? 0 : undefined,\n                direction: direction,\n                showGoBack: !!routeInfo.pushedByRoute,\n                progressAnimation: false,\n                animationBuilder: routeInfo.routeAnimation,\n            });\n        }\n    }\n    render() {\n        const { children } = this.props;\n        const ionRouterOutlet = React.Children.only(children);\n        this.ionRouterOutlet = ionRouterOutlet;\n        const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {\n            this.forceUpdate();\n        });\n        return (React.createElement(StackContext.Provider, { value: this.stackContextValue }, React.cloneElement(ionRouterOutlet, {\n            ref: (node) => {\n                if (ionRouterOutlet.props.setRef) {\n                    ionRouterOutlet.props.setRef(node);\n                }\n                if (ionRouterOutlet.props.forwardedRef) {\n                    ionRouterOutlet.props.forwardedRef.current = node;\n                }\n                this.routerOutletElement = node;\n                const { ref } = ionRouterOutlet;\n                if (typeof ref === 'function') {\n                    ref(node);\n                }\n            },\n        }, components)));\n    }\n    static get contextType() {\n        return RouteManagerContext;\n    }\n}\nfunction matchRoute(node, routeInfo) {\n    let matchedNode;\n    React.Children.forEach(node, (child) => {\n        const matchProps = {\n            exact: child.props.exact,\n            path: child.props.path || child.props.from,\n            component: child.props.component,\n        };\n        const match = matchPath$1(routeInfo.pathname, matchProps);\n        if (match) {\n            matchedNode = child;\n        }\n    });\n    if (matchedNode) {\n        return matchedNode;\n    }\n    // If we haven't found a node\n    // try to find one that doesn't have a path or from prop, that will be our not found route\n    React.Children.forEach(node, (child) => {\n        if (!(child.props.path || child.props.from)) {\n            matchedNode = child;\n        }\n    });\n    return matchedNode;\n}\nfunction matchComponent(node, pathname, forceExact) {\n    const matchProps = {\n        exact: forceExact ? true : node.props.exact,\n        path: node.props.path || node.props.from,\n        component: node.props.component,\n    };\n    const match = matchPath$1(pathname, matchProps);\n    return match;\n}\n\nclass IonRouterInner extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.exitViewFromOtherOutletHandlers = [];\n        this.locationHistory = new LocationHistory();\n        this.viewStack = new ReactRouterViewStack();\n        this.routeMangerContextState = {\n            canGoBack: () => this.locationHistory.canGoBack(),\n            clearOutlet: this.viewStack.clear,\n            findViewItemByPathname: this.viewStack.findViewItemByPathname,\n            getChildrenToRender: this.viewStack.getChildrenToRender,\n            goBack: () => this.handleNavigateBack(),\n            createViewItem: this.viewStack.createViewItem,\n            findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n            findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n            addViewItem: this.viewStack.add,\n            unMountViewItem: this.viewStack.remove,\n        };\n        const routeInfo = {\n            id: generateId('routeInfo'),\n            pathname: this.props.location.pathname,\n            search: this.props.location.search,\n        };\n        this.locationHistory.add(routeInfo);\n        this.handleChangeTab = this.handleChangeTab.bind(this);\n        this.handleResetTab = this.handleResetTab.bind(this);\n        this.handleNativeBack = this.handleNativeBack.bind(this);\n        this.handleNavigate = this.handleNavigate.bind(this);\n        this.handleNavigateBack = this.handleNavigateBack.bind(this);\n        this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n        this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n        this.state = {\n            routeInfo,\n        };\n    }\n    handleChangeTab(tab, path, routeOptions) {\n        if (!path) {\n            return;\n        }\n        const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n        const [pathname, search] = path.split('?');\n        if (routeInfo) {\n            this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), { routeAction: 'push', routeDirection: 'none' });\n            if (routeInfo.pathname === pathname) {\n                this.incomingRouteParams.routeOptions = routeOptions;\n                this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n            }\n            else {\n                this.incomingRouteParams.pathname = pathname;\n                this.incomingRouteParams.search = search ? '?' + search : undefined;\n                this.incomingRouteParams.routeOptions = routeOptions;\n                this.props.history.push(pathname + (search ? '?' + search : ''));\n            }\n        }\n        else {\n            this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n        }\n    }\n    handleHistoryChange(location, action) {\n        var _a, _b, _c;\n        let leavingLocationInfo;\n        if (this.incomingRouteParams) {\n            if (this.incomingRouteParams.routeAction === 'replace') {\n                leavingLocationInfo = this.locationHistory.previous();\n            }\n            else {\n                leavingLocationInfo = this.locationHistory.current();\n            }\n        }\n        else {\n            leavingLocationInfo = this.locationHistory.current();\n        }\n        const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n        if (leavingUrl !== location.pathname) {\n            if (!this.incomingRouteParams) {\n                if (action === 'REPLACE') {\n                    this.incomingRouteParams = {\n                        routeAction: 'replace',\n                        routeDirection: 'none',\n                        tab: this.currentTab,\n                    };\n                }\n                if (action === 'POP') {\n                    const currentRoute = this.locationHistory.current();\n                    if (currentRoute && currentRoute.pushedByRoute) {\n                        const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n                        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: 'pop', routeDirection: 'back' });\n                    }\n                    else {\n                        this.incomingRouteParams = {\n                            routeAction: 'pop',\n                            routeDirection: 'none',\n                            tab: this.currentTab,\n                        };\n                    }\n                }\n                if (!this.incomingRouteParams) {\n                    this.incomingRouteParams = {\n                        routeAction: 'push',\n                        routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || 'forward',\n                        routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,\n                        tab: this.currentTab,\n                    };\n                }\n            }\n            let routeInfo;\n            if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {\n                routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });\n                this.locationHistory.add(routeInfo);\n            }\n            else {\n                const isPushed = this.incomingRouteParams.routeAction === 'push' &&\n                    this.incomingRouteParams.routeDirection === 'forward';\n                routeInfo = Object.assign(Object.assign({ id: generateId('routeInfo') }, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.pathname, search: location.search, params: this.props.match.params, prevRouteLastPathname: leavingLocationInfo.lastPathname });\n                if (isPushed) {\n                    routeInfo.tab = leavingLocationInfo.tab;\n                    routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n                }\n                else if (routeInfo.routeAction === 'pop') {\n                    const r = this.locationHistory.findLastLocation(routeInfo);\n                    routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;\n                }\n                else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n                    // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n                    const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n                    routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n                }\n                else if (routeInfo.routeAction === 'replace') {\n                    // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n                    const currentRouteInfo = this.locationHistory.current();\n                    /**\n                     * If going from /home to /child, then replacing from\n                     * /child to /home, we don't want the route info to\n                     * say that /home was pushed by /home which is not correct.\n                     */\n                    const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n                    const pushedByRoute = (currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname) ? currentPushedBy : routeInfo.pushedByRoute;\n                    routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n                    routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n                    routeInfo.pushedByRoute = pushedByRoute;\n                    routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;\n                    routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;\n                }\n                this.locationHistory.add(routeInfo);\n            }\n            this.setState({\n                routeInfo,\n            });\n        }\n        this.incomingRouteParams = undefined;\n    }\n    /**\n     * history@4.x uses goBack(), history@5.x uses back()\n     * TODO: If support for React Router <=5 is dropped\n     * this logic is no longer needed. We can just\n     * assume back() is available.\n     */\n    handleNativeBack() {\n        const history = this.props.history;\n        const goBack = history.goBack || history.back;\n        goBack();\n    }\n    handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {\n        this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n            routeAction,\n            routeDirection,\n            routeOptions,\n            routeAnimation,\n            tab,\n        });\n        if (routeAction === 'push') {\n            this.props.history.push(path);\n        }\n        else {\n            this.props.history.replace(path);\n        }\n    }\n    handleNavigateBack(defaultHref = '/', routeAnimation) {\n        const config = getConfig();\n        defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref');\n        const routeInfo = this.locationHistory.current();\n        if (routeInfo && routeInfo.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n            if (prevInfo) {\n                this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: 'pop', routeDirection: 'back', routeAnimation: routeAnimation || routeInfo.routeAnimation });\n                if (routeInfo.lastPathname === routeInfo.pushedByRoute ||\n                    (\n                    /**\n                     * We need to exclude tab switches/tab\n                     * context changes here because tabbed\n                     * navigation is not linear, but router.back()\n                     * will go back in a linear fashion.\n                     */\n                    prevInfo.pathname === routeInfo.pushedByRoute &&\n                        routeInfo.tab === '' && prevInfo.tab === '')) {\n                    /**\n                     * history@4.x uses goBack(), history@5.x uses back()\n                     * TODO: If support for React Router <=5 is dropped\n                     * this logic is no longer needed. We can just\n                     * assume back() is available.\n                     */\n                    const history = this.props.history;\n                    const goBack = history.goBack || history.back;\n                    goBack();\n                }\n                else {\n                    this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n                }\n            }\n            else {\n                this.handleNavigate(defaultHref, 'pop', 'back');\n            }\n        }\n        else {\n            this.handleNavigate(defaultHref, 'pop', 'back');\n        }\n    }\n    handleResetTab(tab, originalHref, originalRouteOptions) {\n        const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n        if (routeInfo) {\n            const newRouteInfo = Object.assign({}, routeInfo);\n            newRouteInfo.pathname = originalHref;\n            newRouteInfo.routeOptions = originalRouteOptions;\n            this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routeAction: 'pop', routeDirection: 'back' });\n            this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n        }\n    }\n    handleSetCurrentTab(tab) {\n        this.currentTab = tab;\n        const ri = Object.assign({}, this.locationHistory.current());\n        if (ri.tab !== tab) {\n            ri.tab = tab;\n            this.locationHistory.update(ri);\n        }\n    }\n    render() {\n        return (React.createElement(RouteManagerContext.Provider, { value: this.routeMangerContextState },\n            React.createElement(NavManager, { ionRoute: IonRouteInner, ionRedirect: {}, stackManager: StackManager, routeInfo: this.state.routeInfo, onNativeBack: this.handleNativeBack, onNavigateBack: this.handleNavigateBack, onNavigate: this.handleNavigate, onSetCurrentTab: this.handleSetCurrentTab, onChangeTab: this.handleChangeTab, onResetTab: this.handleResetTab, locationHistory: this.locationHistory }, this.props.children)));\n    }\n}\nconst IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n\nclass IonReactRouter extends React.Component {\n    constructor(props) {\n        super(props);\n        const { history } = props, rest = __rest(props, [\"history\"]);\n        this.history = history || createBrowserHistory(rest);\n        this.history.listen(this.handleHistoryChange.bind(this));\n        this.registerHistoryListener = this.registerHistoryListener.bind(this);\n    }\n    /**\n     * history@4.x passes separate location and action\n     * params. history@5.x passes location and action\n     * together as a single object.\n     * TODO: If support for React Router <=5 is dropped\n     * this logic is no longer needed. We can just assume\n     * a single object with both location and action.\n     */\n    handleHistoryChange(location, action) {\n        const locationValue = location.location || location;\n        const actionValue = location.action || action;\n        if (this.historyListenHandler) {\n            this.historyListenHandler(locationValue, actionValue);\n        }\n    }\n    registerHistoryListener(cb) {\n        this.historyListenHandler = cb;\n    }\n    render() {\n        const _a = this.props, { children } = _a, props = __rest(_a, [\"children\"]);\n        return (React.createElement(Router, Object.assign({ history: this.history }, props),\n            React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)));\n    }\n}\n\nclass IonReactMemoryRouter extends React.Component {\n    constructor(props) {\n        super(props);\n        this.history = props.history;\n        this.history.listen(this.handleHistoryChange.bind(this));\n        this.registerHistoryListener = this.registerHistoryListener.bind(this);\n    }\n    /**\n     * history@4.x passes separate location and action\n     * params. history@5.x passes location and action\n     * together as a single object.\n     * TODO: If support for React Router <=5 is dropped\n     * this logic is no longer needed. We can just assume\n     * a single object with both location and action.\n     */\n    handleHistoryChange(location, action) {\n        const locationValue = location.location || location;\n        const actionValue = location.action || action;\n        if (this.historyListenHandler) {\n            this.historyListenHandler(locationValue, actionValue);\n        }\n    }\n    registerHistoryListener(cb) {\n        this.historyListenHandler = cb;\n    }\n    render() {\n        const _a = this.props, { children } = _a, props = __rest(_a, [\"children\"]);\n        return (React.createElement(Router$1, Object.assign({}, props),\n            React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)));\n    }\n}\n\nclass IonReactHashRouter extends React.Component {\n    constructor(props) {\n        super(props);\n        const { history } = props, rest = __rest(props, [\"history\"]);\n        this.history = history || createHashHistory(rest);\n        this.history.listen(this.handleHistoryChange.bind(this));\n        this.registerHistoryListener = this.registerHistoryListener.bind(this);\n    }\n    /**\n     * history@4.x passes separate location and action\n     * params. history@5.x passes location and action\n     * together as a single object.\n     * TODO: If support for React Router <=5 is dropped\n     * this logic is no longer needed. We can just assume\n     * a single object with both location and action.\n     */\n    handleHistoryChange(location, action) {\n        const locationValue = location.location || location;\n        const actionValue = location.action || action;\n        if (this.historyListenHandler) {\n            this.historyListenHandler(locationValue, actionValue);\n        }\n    }\n    registerHistoryListener(cb) {\n        this.historyListenHandler = cb;\n    }\n    render() {\n        const _a = this.props, { children } = _a, props = __rest(_a, [\"children\"]);\n        return (React.createElement(Router, Object.assign({ history: this.history }, props),\n            React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)));\n    }\n}\n\nexport { IonReactHashRouter, IonReactMemoryRouter, IonReactRouter };\n//# sourceMappingURL=index.esm.js.map\n"]},"metadata":{},"sourceType":"module"}